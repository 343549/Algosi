# Лабораторная работа №3: Быстрая сортировка, сортировки за линейное время

**Вариант:** 19  
**Студент:** Джафари Хоссаин

## Содержание

1. [Введение](#введение)
2. [Задание 1: Улучшение Quick sort](#задание-1-улучшение-quick-sort)
3. [Задание 2: Анти-quick sort](#задание-2-анти-quick-sort)
4. [Задание 8: K ближайших точек к началу координат](#задание-8-k-ближайших-точек-к-началу-координат)
5. [Общий вывод](#общий-вывод)

---

## Введение

Данная лабораторная работа посвящена изучению алгоритмов сортировки, в частности:
- Быстрой сортировки (QuickSort) и её улучшений
- Генерации худших случаев для алгоритмов
- Решению задач вычислительной геометрии

Для варианта 19 необходимо решить задачи: **1, 2, 8**.


## Задание 1: Улучшение Quick sort

### Описание задачи

Задача состоит из двух частей:
1. Реализовать Randomized QuickSort с обычной процедурой разделения (Partition)
2. Улучшить алгоритм, используя трёхстороннее разделение (Partition3) для эффективной обработки последовательностей с множеством одинаковых элементов

### Реализация

#### 1.1. Randomized QuickSort с обычным Partition

Реализована стандартная быстрая сортировка с рандомизацией выбора опорного элемента:

```python
def randomized_quicksort(arr, left, right):
    if left < right:
        pivot_index = randomized_partition(arr, left, right)
        randomized_quicksort(arr, left, pivot_index - 1)
        randomized_quicksort(arr, pivot_index + 1, right)
```

**Сложность:**
- Средний случай: O(n log n)
- Худший случай: O(n²)

#### 1.2. Randomized QuickSort с Partition3

Реализована улучшенная версия с трёхсторонним разделением (алгоритм Dutch National Flag).
Важно: как и в `Partition` со страницы 8, опорный элемент берётся как **первый** элемент подмассива `A[l]`.

```python
def partition3(arr, left, right):
    """
    Разделяет массив на три части:
    - элементы < pivot
    - элементы = pivot  
    - элементы > pivot
    """
    pivot = arr[left]
    i = left
    j = left + 1
    k = right + 1

    while j < k:
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
            j += 1
        elif arr[j] == pivot:
            j += 1
        else:
            k -= 1
            arr[j], arr[k] = arr[k], arr[j]

    # ставим pivot на границу "< pivot"
    arr[left], arr[i] = arr[i], arr[left]

    # собираем блок "== pivot" сразу после pivot
    m1 = i
    m2 = i
    j = i + 1
    while j < k:
        if arr[j] == pivot:
            m2 += 1
            arr[m2], arr[j] = arr[j], arr[m2]
        j += 1

    return m1, m2
```

**Преимущества Partition3:**
- Эффективно обрабатывает массивы с множеством одинаковых элементов
- Не сортирует элементы, равные опорному (они уже на своих местах)
- Уменьшает количество рекурсивных вызовов

### Тестирование

#### Пример из задания:
**Вход:** `5\n2 3 9 2 2`  
**Выход:** `2 2 2 3 9`

Все три алгоритма (QuickSort, QuickSort3, MergeSort) дают одинаковый результат.

#### Сравнение производительности:

**Тест 1: Случайный массив (1000 элементов)**
- QuickSort (Partition): ~0.001 сек
- QuickSort (Partition3): ~0.001 сек
- MergeSort: ~0.001 сек

**Тест 2: Много одинаковых элементов (1000 элементов, 5 уникальных)**
- QuickSort (Partition): ~0.008 сек
- QuickSort (Partition3): ~0.000 сек ⚡
- MergeSort: ~0.001 сек

### Вывод по заданию 1

**Основные результаты:**

1. **Randomized QuickSort** с обычным Partition работает хорошо на случайных данных, но деградирует при наличии множества одинаковых элементов, так как продолжает рекурсивно обрабатывать элементы, равные опорному.

2. **Randomized QuickSort с Partition3** показывает значительное улучшение производительности на массивах с повторяющимися элементами. Трёхстороннее разделение позволяет сразу разместить все элементы, равные опорному, на правильных позициях, избегая их дальнейшей обработки.

3. **MergeSort** показывает стабильную производительность O(n log n) во всех случаях, но требует дополнительной памяти O(n).

## Задание 2: Анти-quick sort

### Описание задачи

Требуется написать программу, генерирующую перестановку чисел от 1 до n, на которой быстрая сортировка выполнит максимальное число сравнений.

Данный алгоритм QuickSort использует средний элемент как опорный:
```python
key = a[(left + right) // 2]
```

### Реализация

Для генерации худшего случая используется рекурсивный подход:

```python
def generate_worst_case_optimized(n):
    """
    Генерирует перестановку, где опорный элемент (средний)
    всегда минимальный в текущем подмассиве
    """
    result = [0] * n
    
    def fill_worst(left, right, start_val):
        if left > right:
            return
        if left == right:
            result[left] = start_val
            return
        
        mid = (left + right) // 2
        # Минимальный элемент в середине (опорный)
        result[mid] = start_val
        
        # Обрабатываем правую часть (меньшие значения)
        fill_worst(mid + 1, right, start_val + 1)
        # Обрабатываем левую часть (большие значения)
        fill_worst(left, mid - 1, start_val + (right - mid) + 1)
    
    fill_worst(0, n - 1, 1)
    return result
```

**Идея алгоритма:**
- Размещаем минимальный элемент в середине подмассива (на позиции опорного элемента)
- Это гарантирует, что опорный элемент всегда будет минимальным
- Рекурсивно применяем эту стратегию к левой и правой частям

### Примеры

**Вход:** `3`  
**Выход:** `1 3 2`

Для n=3 алгоритм генерирует перестановку, где средний элемент (индекс 1) является минимальным (1), что приводит к максимальному числу сравнений.

### Вывод по заданию 2

**Основные результаты:**

1. **Понимание худшего случая:** Задача демонстрирует важность анализа худших случаев для алгоритмов. QuickSort, хотя и быстр в среднем, может деградировать до O(n²) на специально подобранных данных.

2. **Стратегия генерации:** Ключевая идея — размещать минимальный (или максимальный) элемент на позиции опорного элемента, что приводит к максимально несбалансированному разбиению на каждом шаге.


## Задание 8: K ближайших точек к началу координат

### Описание задачи

Найти K ближайших точек к началу координат (0, 0) среди n заданных точек на плоскости.

Расстояние между точкой (x, y) и началом координат вычисляется по формуле:
```
distance = √(x² + y²)
```

### Реализация

```python
def find_k_nearest_points(n, k, points):
    """
    Находит K ближайших точек к началу координат
    """
    # Вычисляем квадрат расстояния для каждой точки
    points_with_distance = []
    for point in points:
        x, y = point
        dist_sq = x * x + y * y  # Не извлекаем корень - не нужно
        points_with_distance.append((dist_sq, point))
    
    # Сортируем по квадрату расстояния
    points_with_distance.sort(key=lambda x: x[0])
    
    # Берём первые K точек
    k_nearest = [point for _, point in points_with_distance[:k]]
    return k_nearest
```

**Оптимизация:**
- Используем квадрат расстояния вместо самого расстояния (избегаем извлечения корня)
- Сортировка по квадрату расстояния эквивалентна сортировке по расстоянию
- Это экономит вычислительные ресурсы

**Сложность:**
- Время: O(n log n) — из-за сортировки
- Память: O(n)

### Примеры

**Пример 1:**
**Вход:**
```
2 1
1 3
-2 2
```
**Выход:** `[-2,2]`

Расстояния:
- (1, 3): √(1² + 3²) = √10 ≈ 3.16
- (-2, 2): √((-2)² + 2²) = √8 ≈ 2.83

Ближайшая точка: (-2, 2)

**Пример 2:**
**Вход:**
```
3 2
3 3
5 -1
-2 4
```
**Выход:** `[3,3],[-2,4]`

Расстояния:
- (3, 3): √18 ≈ 4.24
- (5, -1): √26 ≈ 5.10
- (-2, 4): √20 ≈ 4.47

Две ближайшие: (3, 3) и (-2, 4)

### Вывод по заданию 8

**Основные результаты:**

1. **Эффективное решение:** Задача решается простой сортировкой точек по расстоянию до начала координат с последующим выбором первых K элементов. Это оптимальное решение для данной задачи.

2. **Оптимизация вычислений:** Использование квадрата расстояния вместо самого расстояния — классическая оптимизация, которая экономит время на извлечении корня, не влияя на результат сортировки.

3. **Применение:** Подобные задачи часто встречаются в:
   - Геолокационных приложениях (поиск ближайших объектов)
   - Компьютерной графике (выбор ближайших точек)
   - Машинном обучении (k-nearest neighbors)

**Практический вывод:** Задача демонстрирует, как простое применение сортировки позволяет эффективно решать задачи вычислительной геометрии. Важно помнить о математических оптимизациях (квадрат расстояния вместо расстояния), которые могут ускорить решение без изменения результата.


## Общий вывод

В ходе выполнения лабораторной работы были реализованы и изучены три различные задачи, связанные с алгоритмами сортировки и вычислительной геометрией.

Эта лабораторная работа научила нескольким важным вещам:

- **Алгоритмы можно улучшать** под конкретные задачи. QuickSort с трёхсторонним разделением работает намного быстрее, когда в данных много одинаковых элементов.

- **Нет идеальных алгоритмов** — каждый имеет свои сильные и слабые стороны. QuickSort быстр в среднем, но может быть медленным на специально подобранных данных. MergeSort всегда стабилен, но требует больше памяти.

- **Математика помогает оптимизировать** — использование квадрата расстояния вместо расстояния экономит время, не меняя результат.

- **Понимание худших случаев важно** — это помогает выбирать правильные алгоритмы и защищаться от проблем производительности.


## Структура проекта

```
lab3/
├── task1/                      # Задача 1
│   ├── task1_quicksort.py
│   ├── test_task1.py
│   └── input_task1.txt
├── task2/                      # Задача 2
│   ├── task2_anti_quicksort.py
│   ├── test_task2.py
│   └── input_task2.txt
├── task8/                      # Задача 8
│   ├── task8_k_nearest_points.py
│   ├── test_task8.py
│   └── input_task8.txt
└── README.md                   # Данный отчёт
```

## Запуск программ

### Задача 1:
```bash
# Вариант 1: запуск из корня
python task1/task1_quicksort.py

# Вариант 2: запуск из папки задачи
cd task1
python task1_quicksort.py
# Результат будет в output.txt
```

### Задача 2:
```bash
# Вариант 1: запуск из корня
python task2/task2_anti_quicksort.py

# Вариант 2: запуск из папки задачи
cd task2
python task2_anti_quicksort.py
# Результат будет в output.txt
```

### Задача 8:
```bash
# Вариант 1: запуск из корня
python task8/task8_k_nearest_points.py

# Вариант 2: запуск из папки задачи
cd task8
python task8_k_nearest_points.py
# Результат будет в output.txt
```

