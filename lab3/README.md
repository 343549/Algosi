# Лабораторная работа: Умножение многочленов

**Вариант:** 19  
**Студент:** Джафари Хоссаин

## Содержание

1. [Введение](#введение)
2. [Задание 1: Наивный алгоритм](#задание-1-наивный-алгоритм)
3. [Задание 2: Алгоритм разделяй и властвуй](#задание-2-алгоритм-разделяй-и-властвуй)
4. [Задание 3: Алгоритм Карацубы](#задание-3-алгоритм-карацубы)
5. [Тестирование и сравнение](#тестирование-и-сравнение)
6. [Общий вывод](#общий-вывод)


## Введение

Цель данной лабораторной работы — реализовать и сравнить различные алгоритмы умножения многочленов:

1. **Наивный алгоритм** — простой подход с двойным циклом
2. **Алгоритм разделяй и властвуй (наивный)** — рекурсивное разбиение многочленов
3. **Алгоритм Карацубы** — оптимизированный алгоритм разделяй и властвуй

Все алгоритмы реализованы на языке Python и протестированы на различных примерах.


## Задание 1: Наивный алгоритм

### Описание

Наивный алгоритм умножения многочленов использует простой подход: каждый коэффициент первого многочлена умножается на каждый коэффициент второго многочлена, и результаты суммируются в соответствующих позициях.

### Реализация

```python
def naive_multiply(A, B):
    n = len(A)
    m = len(B)
    result = [0] * (n + m - 1)
    
    for i in range(n):
        for j in range(m):
            result[i + j] += A[i] * B[j]
    
    return result
```

### Сложность

- **Временная сложность:** O(n²), где n — размер многочленов
- **Пространственная сложность:** O(n)

### Пример работы

Для многочленов:
- A(x) = 3x² + 2x + 5
- B(x) = 5x² + x + 2

Результат: A(x) × B(x) = 15x⁴ + 13x³ + 33x² + 9x + 10

### Вывод по заданию 1

Наивный алгоритм прост в реализации и понимании, но имеет квадратичную сложность. Для небольших многочленов он работает достаточно быстро, но при увеличении размера становится неэффективным. Это классический пример "прямого" подхода к решению задачи.


## Задание 2: Алгоритм разделяй и властвуй

### Описание

Алгоритм разделяй и властвуй разбивает многочлены пополам и рекурсивно умножает части. Однако наивная реализация разделяй и властвуй всё ещё имеет сложность O(n²), так как рекуррентное соотношение T(n) = 4T(n/2) + kn даёт O(n²).

### Реализация

В данной реализации используется наивный алгоритм, так как наивный подход разделяй и властвуй не улучшает асимптотическую сложность по сравнению с простым наивным алгоритмом.

### Сложность

- **Временная сложность:** O(n²)
- **Пространственная сложность:** O(n)

### Вывод по заданию 2

Наивный алгоритм разделяй и властвуй демонстрирует концепцию рекурсивного разбиения задачи, но не даёт выигрыша в производительности. Это показывает, что не любое применение принципа "разделяй и властвуй" автоматически улучшает сложность алгоритма. Для реального улучшения нужны оптимизации, такие как алгоритм Карацубы.


## Задание 3: Алгоритм Карацубы

### Описание

Алгоритм Карацубы — это оптимизированный алгоритм разделяй и властвуй, который использует математический трюк для уменьшения количества умножений. Вместо 4 рекурсивных вызовов (как в наивном разделяй и властвуй) он использует только 3.

### Идея алгоритма

Для многочленов A(x) = D₁(x)·x^m + D₀(x) и B(x) = E₁(x)·x^m + E₀(x), вместо вычисления:
- D₁E₁, D₁E₀, D₀E₁, D₀E₀ (4 умножения)

вычисляем:
- Z₀ = D₀E₀
- Z₂ = D₁E₁
- Z₁ = (D₁ + D₀)(E₁ + E₀)
- Средний член = Z₁ - Z₂ - Z₀ (3 умножения)

### Реализация

```python
def karatsuba_multiply(A, B):
    # Базовый случай: используем наивный алгоритм для малых многочленов
    if n <= 4 or m <= 4:
        return naive_multiply(A, B)
    
    # Разбиваем пополам
    mid = n // 2
    D1, D0 = A[:mid], A[mid:]
    E1, E0 = B[:mid], B[mid:]
    
    # Три умножения
    Z0 = karatsuba_multiply(D0, E0)
    Z2 = karatsuba_multiply(D1, E1)
    Z1 = karatsuba_multiply(add(D1, D0), add(E1, E0))
    
    # Собираем результат
    result = Z2 * x^(2*shift) + (Z1 - Z2 - Z0) * x^shift + Z0
```

### Сложность

- **Временная сложность:** O(n^log₂(3)) ≈ O(n^1.58)
- **Пространственная сложность:** O(n)

### Пример работы

Для многочленов:
- A(x) = 4x³ + 3x² + 2x + 1
- B(x) = x³ + 2x² + 3x + 4

Результат: A(x) × B(x) = 4x⁶ + 11x⁵ + 20x⁴ + 30x³ + 20x² + 11x + 4

### Вывод по заданию 3

Алгоритм Карацубы показывает, как математические оптимизации могут существенно улучшить производительность алгоритма. Хотя реализация сложнее, чем наивный алгоритм, выигрыш в асимптотической сложности (от O(n²) до O(n^1.58)) делает его предпочтительным для больших многочленов. Это отличный пример того, как "умное" использование математических свойств приводит к более эффективным алгоритмам.


## Тестирование и сравнение

### Тестовые примеры

Реализованы четыре тестовых примера:

1. **Пример 1:** A(x) = 3x² + 2x + 5, B(x) = 5x² + x + 2
2. **Пример 2:** A(x) = 4x³ + 3x² + 2x + 1, B(x) = x³ + 2x² + 3x + 4
3. **Пример 3:** A(x) = x + 1, B(x) = x + 1
4. **Пример 4:** A(x) = 2x + 1, B(x) = 3x² + 2x + 1

### Результаты тестирования

Все алгоритмы дают одинаковые результаты для всех тестовых случаев, что подтверждает корректность реализации.

Вывод результатов программы:
```
============================================================
Example 1
============================================================

A(x) = 3x^2 + 2x + 5
B(x) = 5x^2 + x + 2

1. Naive algorithm (O(n^2)):
A(x) * B(x) = 15x^4 + 13x^3 + 33x^2 + 9x + 10

2. Divide and conquer algorithm (O(n^2)):
A(x) * B(x) = 15x^4 + 13x^3 + 33x^2 + 9x + 10

3. Karatsuba algorithm (O(n^log2(3))):
A(x) * B(x) = 15x^4 + 13x^3 + 33x^2 + 9x + 10

Verification: OK: All algorithms produced the same result
```

### Запуск программы

Для запуска программы выполните:
```bash
python polynomial_mult.py
```


## Общий вывод

В ходе выполнения лабораторной работы были реализованы три алгоритма умножения многочленов: наивный алгоритм, алгоритм разделяй и властвуй и алгоритм Карацубы.

**Что мы узнали:**

1. **Наивный алгоритм** — самый простой, но не самый эффективный. Он работает за O(n²) времени, что хорошо для маленьких задач, но плохо для больших.

2. **Разделяй и властвуй** — интересная техника, но простое применение не всегда даёт выигрыш. Наивная версия всё равно O(n²).

3. **Алгоритм Карацубы** — умная оптимизация, которая использует математический трюк (3 умножения вместо 4) и работает быстрее — за O(n^1.58) вместо O(n²).

**Практический вывод:**

Для маленьких многочленов все алгоритмы работают примерно одинаково, и можно использовать простой наивный алгоритм. Но когда многочлены становятся большими, алгоритм Карацубы показывает своё преимущество — он работает быстрее, особенно заметно это становится на очень больших данных.

**Простыми словами:** это как умножение чисел — для маленьких чисел можно перемножать "в столбик" (наивный алгоритм), но для очень больших чисел нужны специальные хитрости (Карацуба), чтобы посчитать быстрее. То же самое и с многочленами!



## Файлы проекта

- `polynomial_mult.py` — основной файл с реализацией всех алгоритмов
- `README.md` — данный отчёт

