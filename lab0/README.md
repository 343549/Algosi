# Лабораторная работа №0
## Введение в алгоритмы

**Студент:** Джафари Хоссаин  
**Вариант:** 19  
**Дата:** 2025

---

## Задание 1. Ввод-вывод

Вам необходимо выполнить 4 следующих задачи:

1. Задача `a + b`. Вычислить сумму двух заданных чисел.
2. Задача `a + b²`. Вычислить значение `a + b²`.
3. Выполнить задачу `a + b` с использованием файлов (input.txt → output.txt).
4. Выполнить задачу `a + b²` с использованием файлов (input.txt → output.txt).

**Общие ограничения:**
- Входные данные: два целых числа `a` и `b`
- Диапазон значений: `-10^9 ≤ a, b ≤ 10^9`

---

## Задача 1: a + b (стандартный ввод-вывод)

### Описание

Вычислить сумму двух целых чисел `a` и `b`.

**Вход:** одна строка, содержащая два целых числа `a` и `b`.  
**Выход:** единственное целое число — результат сложения `a + b`.

### Алгоритм решения

**Временная сложность:** O(1)  
**Пространственная сложность:** O(1)

### Реализация

Файл: `sum_ab.py`

```python
"""Сумма двух целых чисел a + b.

Читает из stdin строку с двумя числами, выводит их сумму.
Ограничения: -1e9 <= a, b <= 1e9.
"""

import sys


def main() -> None:
    data = sys.stdin.read().strip().split()
    if len(data) != 2:
        sys.exit("Ожидалось два числа")
    a, b = map(int, data)
    if not (-10**9 <= a <= 10**9 and -10**9 <= b <= 10**9):
        sys.exit("Числа должны быть в диапазоне [-1e9, 1e9]")
    print(a + b)


if __name__ == "__main__":
    main()
```

### Тестирование

```bash
# Тест 1
echo "5 3" | python sum_ab.py
# Ожидаемый вывод: 8

# Тест 2
echo "-10 20" | python sum_ab.py
# Ожидаемый вывод: 10

# Тест 3
echo "0 0" | python sum_ab.py
# Ожидаемый вывод: 0
```

## Задача 2: a + b² (стандартный ввод-вывод)

### Описание

Вычислить значение `a + b²`.

**Вход:** одна строка, содержащая два целых числа `a` и `b`.  
**Выход:** единственное целое число — результат вычисления `a + b²`.

### Алгоритм решения

**Временная сложность:** O(1)  
**Пространственная сложность:** O(1)

### Реализация

Файл: `sum_ab_squared.py`

```python
"""Сумма числа a и квадрата числа b (a + b²).

Читает из stdin строку с двумя числами, выводит результат a + b².
Ограничения: -1e9 <= a, b <= 1e9.
"""

import sys


def main() -> None:
    data = sys.stdin.read().strip().split()
    if len(data) != 2:
        sys.exit("Ожидалось два числа")
    a, b = map(int, data)
    if not (-10**9 <= a <= 10**9 and -10**9 <= b <= 10**9):
        sys.exit("Числа должны быть в диапазоне [-1e9, 1e9]")
    result = a + b * b
    print(result)


if __name__ == "__main__":
    main()
```

### Тестирование

```bash
# Тест 1: a=5, b=3 → 5 + 3² = 5 + 9 = 14
echo "5 3" | python sum_ab_squared.py
# Ожидаемый вывод: 14

# Тест 2: a=-10, b=4 → -10 + 4² = -10 + 16 = 6
echo "-10 4" | python sum_ab_squared.py
# Ожидаемый вывод: 6

# Тест 3: a=0, b=0 → 0 + 0² = 0
echo "0 0" | python sum_ab_squared.py
# Ожидаемый вывод: 0
```


## Задача 3: a + b (работа с файлами)

### Описание

Выполнить задачу `a + b` с использованием файлов.

**Входной файл:** `input.txt`  
- Формат: одна строка, содержащая два целых числа `a` и `b`, разделённые пробелом

**Выходной файл:** `output.txt`  
- Формат: единственное целое число — результат сложения `a + b`

### Реализация

Файл: `sum_ab_file.py`

```python
"""Сумма двух целых чисел a + b (работа с файлами).

Читает из файла input.txt два числа, выводит сумму в файл output.txt.
Ограничения: -1e9 <= a, b <= 1e9.
"""


def main() -> None:
    with open('input.txt', 'r', encoding='utf-8') as input_file:
        data = input_file.read().strip().split()
    
    if len(data) != 2:
        raise ValueError("Ожидалось два числа")
    
    a, b = map(int, data)
    if not (-10**9 <= a <= 10**9 and -10**9 <= b <= 10**9):
        raise ValueError("Числа должны быть в диапазоне [-1e9, 1e9]")
    
    result = a + b
    
    with open('output.txt', 'w', encoding='utf-8') as output_file:
        output_file.write(str(result))


if __name__ == "__main__":
    main()
```

### Тестирование

**Пример 1:**
```
input.txt:  12 25
output.txt: 37
```

**Пример 2:**
```
input.txt:  130 61
output.txt: 191
```

```bash
# Подготовка теста
echo "12 25" > input.txt
python sum_ab_file.py
cat output.txt
# Ожидаемый вывод: 37
```

---

## Задача 4: a + b² (работа с файлами)

### Описание

Выполнить задачу `a + b²` с использованием файлов аналогично предыдущему пункту.

**Входной файл:** `input.txt`  
- Формат: одна строка, содержащая два целых числа `a` и `b`, разделённые пробелом

**Выходной файл:** `output.txt`  
- Формат: единственное целое число — результат вычисления `a + b²`

### Реализация

Файл: `sum_ab_squared_file.py`

```python
"""Сумма числа a и квадрата числа b (a + b²) (работа с файлами).

Читает из файла input.txt два числа, выводит результат a + b² в файл output.txt.
Ограничения: -1e9 <= a, b <= 1e9.
"""


def main() -> None:
    with open('input.txt', 'r', encoding='utf-8') as input_file:
        data = input_file.read().strip().split()
    
    if len(data) != 2:
        raise ValueError("Ожидалось два числа")
    
    a, b = map(int, data)
    if not (-10**9 <= a <= 10**9 and -10**9 <= b <= 10**9):
        raise ValueError("Числа должны быть в диапазоне [-1e9, 1e9]")
    
    result = a + b * b
    
    with open('output.txt', 'w', encoding='utf-8') as output_file:
        output_file.write(str(result))


if __name__ == "__main__":
    main()
```

### Тестирование

**Пример 1:**
```
input.txt:  5 3
output.txt: 14  (так как 5 + 3² = 5 + 9 = 14)
```

**Пример 2:**
```
input.txt:  -10 4
output.txt: 6  (так как -10 + 4² = -10 + 16 = 6)
```

```bash
# Подготовка теста
echo "5 3" > input.txt
python sum_ab_squared_file.py
cat output.txt
# Ожидаемый вывод: 14
```

### Выводы по заданию 1

В ходе выполнения задания 1 были реализованы четыре программы для работы с базовыми арифметическими операциями:

**Достигнутые результаты:**
- Освоены основы работы с потоками ввода-вывода (stdin/stdout) в Python
- Реализована работа с файлами для чтения и записи данных
- Изучены особенности использования контекстных менеджеров (`with`) для безопасной работы с файлами
- Отработаны навыки обработки входных данных и проверки граничных значений

**Ключевые умения:**
- Парсинг входных данных из строк
- Проверка корректности входных данных
- Работа с файлами с указанием кодировки UTF-8
- Структурирование кода с использованием функций



## Задание 2. Число Фибоначчи

### Описание задачи

Цель — разработать эффективный алгоритм для подсчёта чисел Фибоначчи.

**Определение последовательности Фибоначчи:**
- `F₀ = 0`
- `F₁ = 1`
- `Fᵢ = Fᵢ₋₁ + Fᵢ₋₂` для `i ≥ 2`

Таким образом, каждое число Фибоначчи представляет собой сумму двух предыдущих, что даёт последовательность:
`0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...`

**Наивный рекурсивный алгоритм (предоставлен в задании):**
```python
def calc_fib(n):
    if (n <= 1):
        return n
    return calc_fib(n - 1) + calc_fib(n - 2)
```

Данный алгоритм имеет экспоненциальную временную сложность O(2ⁿ), что делает его неэффективным для больших значений `n`. Поэтому необходимо реализовать оптимизированное решение.

**Файлы:**
- **Имя входного файла:** `input.txt`
- **Имя выходного файла:** `output.txt`

**Формат входного файла:** целое число `n`. `0 ≤ n ≤ 45`.  
**Формат выходного файла:** число `Fₙ`.

**Пример:**
```
input.txt:  10
output.txt: 55
```

### Анализ алгоритма

**Проблема наивной рекурсии:**
- Временная сложность: O(2ⁿ) — экспоненциальная
- Происходит множественное вычисление одних и тех же значений
- Например, для вычисления `F(5)` функция `F(2)` вызывается 3 раза, `F(3)` — 2 раза

**Оптимизированное решение:**
Используется подход динамического программирования с итеративным вычислением.

**Алгоритм:**
1. Базовые случаи: `F₀ = 0`, `F₁ = 1`
2. Для `i` от 2 до `n` последовательно вычисляем `Fᵢ = Fᵢ₋₁ + Fᵢ₋₂`
3. Храним только два последних значения (предыдущее и предпредыдущее)

**Преимущества:**
- Временная сложность: O(n) — линейная
- Пространственная сложность: O(1) — константная
- Каждое число вычисляется ровно один раз

### Реализация

Файл: `fibonacci.py`

```python
"""Вычисление n-го числа Фибоначчи.

Читает из файла input.txt число n, выводит Fₙ в файл output.txt.
Ограничения: 0 ≤ n ≤ 45.

Определение последовательности Фибоначчи:
F₀ = 0
F₁ = 1
Fᵢ = Fᵢ₋₁ + Fᵢ₋₂ для i ≥ 2
"""


def calc_fib(n: int) -> int:
    """Вычисляет n-е число Фибоначчи с использованием динамического программирования.
    
    Использует итеративный подход для оптимальной временной сложности O(n)
    и пространственной сложности O(1).
    """
    if n <= 1:
        return n
    
    # Используем переменные для хранения двух предыдущих чисел
    prev_prev = 0  # F₀
    prev = 1       # F₁
    
    # Вычисляем числа последовательно от F₂ до Fₙ
    for i in range(2, n + 1):
        current = prev_prev + prev
        prev_prev = prev
        prev = current
    
    return prev


def main() -> None:
    with open('input.txt', 'r', encoding='utf-8') as input_file:
        n = int(input_file.read().strip())
    
    if not (0 <= n <= 45):
        raise ValueError("n должно быть в диапазоне [0, 45]")
    
    result = calc_fib(n)
    
    with open('output.txt', 'w', encoding='utf-8') as output_file:
        output_file.write(str(result))


if __name__ == "__main__":
    main()
```

### Описание реализации

**Ключевые особенности:**
- Использование итеративного подхода вместо рекурсии
- Хранение только двух последних значений (минимизация использования памяти)
- Проверка граничных значений входных данных
- Работа с файлами через контекстные менеджеры

**Временная сложность:** O(n)  
**Пространственная сложность:** O(1)

### Тестирование

**Пример 1:**
```
input.txt:  0
output.txt: 0
```

**Пример 2:**
```
input.txt:  1
output.txt: 1
```

**Пример 3:**
```
input.txt:  10
output.txt: 55
```

**Пример 4 (граничный случай):**
```
input.txt:  45
output.txt: 1134903170
```

**Последовательность Фибоначчи для первых 11 чисел:**
| n  | Fₙ |
|----|-----|
| 0  | 0   |
| 1  | 1   |
| 2  | 1   |
| 3  | 2   |
| 4  | 3   |
| 5  | 5   |
| 6  | 8   |
| 7  | 13  |
| 8  | 21  |
| 9  | 34  |
| 10 | 55  |

```bash
# Тест 1
echo "10" > input.txt
python fibonacci.py
cat output.txt
# Ожидаемый вывод: 55

# Тест 2
echo "0" > input.txt
python fibonacci.py
cat output.txt
# Ожидаемый вывод: 0

# Тест 3
echo "45" > input.txt
python fibonacci.py
cat output.txt
# Ожидаемый вывод: 1134903170
```

### Выводы по заданию 2

При выполнении задания 2 была реализована оптимизированная версия вычисления чисел Фибоначчи:

**Ключевые достижения:**
- Проанализированы недостатки наивного рекурсивного алгоритма (экспоненциальная сложность)
- Реализован эффективный алгоритм с использованием динамического программирования
- Достигнуто значительное улучшение производительности: O(2ⁿ) → O(n) по времени, O(1) по памяти

**Изученные концепции:**
- Динамическое программирование и мемоизация
- Итеративный подход вместо рекурсии
- Оптимизация использования памяти за счёт хранения только необходимых значений
- Анализ временной и пространственной сложности алгоритмов


## Задание 3. Ещё про числа Фибоначчи

### Описание задачи

Определить последнюю цифру n-го числа Фибоначчи для очень больших значений `n`.

**Проблема:**
Числа Фибоначчи растут экспоненциально. Например, F₃₃₁ = 668996615388005031531000081241745415306766517246774551964595292186469. Хранение таких больших чисел в массиве и вычисление их суммы было бы слишком медленным и неэффективным.

**Ключевое наблюдение:**
Найти последнюю цифру любого числа достаточно просто: `F mod 10`. Более того, можно использовать свойство: `(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10`. Это позволяет вычислять только последнюю цифру на каждом шаге, не вычисляя само число полностью.

**Файлы:**
- **Имя входного файла:** `input.txt`
- **Имя выходного файла:** `output.txt`

**Формат входного файла:** целое число `n`. `0 ≤ n ≤ 10^7`.  
**Формат выходного файла:** одна цифра — последняя цифра числа `Fₙ`.

**Ограничения:**
- Временное ограничение: 5 секунд
- Ограничение памяти: 512 МБ

**Примеры:**

**Пример 1:**
```
input.txt:  331
output.txt: 9
```
F₃₃₁ = 668996615388005031531000081241745415306766517246774551964595292186469, последняя цифра — 9.

**Пример 2:**
```
input.txt:  327305
output.txt: 5
```
Это число слишком большое, чтобы записать на странице, но действительно оканчивается на 5.

### Анализ алгоритма

**Подход 1 (прямой):**
Вычислять `(Fᵢ₋₁ + Fᵢ₋₂) mod 10` на каждом шаге. Это работает, но для очень больших `n` (до 10⁷) может быть медленно.

**Подход 2 (оптимизированный — период Пизано):**
Для последней цифры чисел Фибоначчи существует периодичность — период Пизано равен 60. Это означает, что последние цифры чисел Фибоначчи повторяются каждые 60 чисел. Следовательно, достаточно вычислить `n mod 60` и найти последнюю цифру для этого значения.

**Преимущества оптимизации:**
- Вместо вычисления для n = 10⁷ вычисляем для n mod 60 (максимум 59 итераций)
- Временная сложность: O(1) — константная (независимо от значения n)
- Пространственная сложность: O(1)

### Реализация

Файл: `fibonacci_last_digit.py`

```python
"""Вычисление последней цифры n-го числа Фибоначчи.

Читает из файла input.txt число n, выводит последнюю цифру Fₙ в файл output.txt.
Ограничения: 0 ≤ n ≤ 10^7.

Для больших значений n числа Фибоначчи растут экспоненциально и не помещаются
в стандартные типы данных. Однако для нахождения последней цифры достаточно
работать только с остатками от деления на 10.

Используется свойство: (a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10
Также можно использовать период Пизано для последней цифры (период равен 60).
"""


def calc_fib_last_digit(n: int) -> int:
    """Вычисляет последнюю цифру n-го числа Фибоначчи.
    
    Использует оптимизацию: работаем только с остатками от деления на 10,
    что позволяет обрабатывать очень большие значения n (до 10^7).
    
    Временная сложность: O(n)
    Пространственная сложность: O(1)
    """
    if n <= 1:
        return n
    
    # Используем оптимизацию с периодом Пизано (60 для последней цифры)
    # Это позволяет ускорить вычисления для очень больших n
    n_mod_period = n % 60
    
    prev_prev = 0  # F₀ mod 10 = 0
    prev = 1       # F₁ mod 10 = 1
    
    # Вычисляем последнюю цифру чисел Фибоначчи
    for i in range(2, n_mod_period + 1):
        current = (prev_prev + prev) % 10
        prev_prev = prev
        prev = current
    
    return prev


def main() -> None:
    with open('input.txt', 'r', encoding='utf-8') as input_file:
        n = int(input_file.read().strip())
    
    if not (0 <= n <= 10**7):
        raise ValueError("n должно быть в диапазоне [0, 10^7]")
    
    result = calc_fib_last_digit(n)
    
    with open('output.txt', 'w', encoding='utf-8') as output_file:
        output_file.write(str(result))


if __name__ == "__main__":
    main()
```

### Описание реализации

**Ключевые особенности:**
- Использование свойства модульной арифметики: `(a + b) mod 10 = ((a mod 10) + (b mod 10)) mod 10`
- Применение периода Пизано (60) для ускорения вычислений
- Работа только с остатками от деления на 10, что исключает переполнение
- Обработка очень больших значений `n` (до 10⁷) за константное время

**Временная сложность:** O(1) — благодаря периоду Пизано  
**Пространственная сложность:** O(1)

### Тестирование

**Пример 1:**
```
input.txt:  331
output.txt: 9
```

**Пример 2:**
```
input.txt:  327305
output.txt: 5
```

**Пример 3:**
```
input.txt:  0
output.txt: 0
```

**Пример 4:**
```
input.txt:  1
output.txt: 1
```

**Пример 5 (граничный случай):**
```
input.txt:  10000000
output.txt: (вычисляется за O(1) благодаря периоду Пизано)
```

```bash
# Тест 1
echo "331" > input.txt
python fibonacci_last_digit.py
cat output.txt
# Ожидаемый вывод: 9

# Тест 2
echo "327305" > input.txt
python fibonacci_last_digit.py
cat output.txt
# Ожидаемый вывод: 5

# Тест 3
echo "10" > input.txt
python fibonacci_last_digit.py
cat output.txt
# Ожидаемый вывод: 5  (последняя цифра F₁₀ = 55)
```

**Последние цифры первых чисел Фибоначчи:**
| n  | Fₙ | Последняя цифра |
|----|----|-----------------|
| 0  | 0  | 0               |
| 1  | 1  | 1               |
| 2  | 1  | 1               |
| 3  | 2  | 2               |
| 4  | 3  | 3               |
| 5  | 5  | 5               |
| 6  | 8  | 8               |
| 7  | 13 | 3               |
| 8  | 21 | 1               |
| 9  | 34 | 4               |
| 10 | 55 | 5               |

### Выводы по заданию 3

При выполнении задания 3 была решена задача оптимизации вычислений для очень больших значений:

**Ключевые достижения:**
- Освоена работа с модульной арифметикой для избежания переполнения
- Изучено свойство периодичности (период Пизано) в последовательности Фибоначчи
- Реализован алгоритм с константной временной сложностью O(1) независимо от значения `n`

**Изученные концепции:**
- Модульная арифметика: `(a + b) mod m = ((a mod m) + (b mod m)) mod m`
- Период Пизано для последовательностей, задаваемых рекуррентными соотношениями
- Оптимизация вычислений для работы с большими числами без их полного хранения
- Обработка очень больших входных данных (до 10⁷) за оптимальное время



## Задание 4. Тестирование ваших алгоритмов

### Описание задачи

Протестировать время выполнения алгоритмов из **Задания 2** и **Задания 3**. Дополнительно можно протестировать объем используемой памяти при выполнении алгоритмов.

**Цели тестирования:**
- Измерить производительность алгоритмов для различных размеров входных данных
- Проверить, что алгоритмы работают в пределах временных ограничений
- Выявить возможные проблемы производительности
- Проверить корректность результатов

### Методы тестирования

**Измерение времени выполнения:**
- Использование `time.perf_counter()` для точного измерения процессорного времени
- Тестирование для малых, средних и больших значений входных данных
- Анализ зависимости времени выполнения от размера входных данных

**Проверка корректности:**
- Использование альтернативных (возможно, неэффективных) решений для проверки правильности
- Сравнение результатов с известными эталонными значениями
- Проверка граничных случаев (n = 0, n = 1, максимальные значения)

**Выявление проблем:**
- Проверка на бесконечные циклы
- Проверка на переполнение памяти
- Проверка на правильность работы с граничными значениями

### Реализация тестов

Созданы три скрипта для тестирования:

#### 1. Тестирование производительности задания 2

Файл: `test_fibonacci_performance.py`

```python
import time

def calc_fib(n: int) -> int:
    # ... реализация из задания 2 ...

def test_performance():
    test_cases = [
        (0, "малое"), (1, "малое"), (5, "малое"), (10, "малое"),
        (20, "среднее"), (30, "среднее"), (40, "большое"), (45, "большое (максимальное)")
    ]
    
    for n, category in test_cases:
        t_start = time.perf_counter()
        result = calc_fib(n)
        t_end = time.perf_counter()
        elapsed_time = t_end - t_start
        # Вывод результатов...
```

**Что проверяет:**
- Время выполнения для малых, средних и больших значений n
- Соотношение времени выполнения для разных размеров
- Выявление проблем с производительностью

#### 2. Тестирование производительности задания 3

Файл: `test_fibonacci_last_digit_performance.py`

```python
import time

def calc_fib_last_digit(n: int) -> int:
    # ... реализация из задания 3 ...

def test_performance():
    test_cases = [
        (0, "малое"), (1, "малое"), (10, "малое"), (45, "малое"),
        (100, "среднее"), (1000, "среднее"), (10000, "большое"),
        (100000, "большое"), (1000000, "очень большое"),
        (5000000, "очень большое"), (10000000, "очень большое (максимальное)")
    ]
    
    for n, category in test_cases:
        t_start = time.perf_counter()
        result = calc_fib_last_digit(n)
        t_end = time.perf_counter()
        elapsed_time = t_end - t_start
        # Вывод результатов...
```

**Что проверяет:**
- Время выполнения для очень больших значений n (до 10⁷)
- Константность времени выполнения (благодаря периоду Пизано)
- Корректность работы периода Пизано (проверка, что F(n) mod 10 = F(n + 60) mod 10)

#### 3. Проверка корректности алгоритмов

Файл: `test_correctness.py`

```python
def calc_fib_naive(n: int) -> int:
    """Наивная рекурсивная версия для проверки (только для малых n)."""
    if n <= 1:
        return n
    return calc_fib_naive(n - 1) + calc_fib_naive(n - 2)

def test_correctness():
    # Сравнение наивной и оптимизированной версии задания 2
    # Проверка, что последняя цифра из задания 3 совпадает с F(n) mod 10
    # Проверка периода Пизано
```

**Что проверяет:**
- Сравнение результатов наивной и оптимизированной реализации задания 2
- Проверка, что последняя цифра из задания 3 равна F(n) mod 10 из задания 2
- Проверка корректности работы периода Пизано

### Запуск тестов

```bash
# Тестирование производительности задания 2
python test_fibonacci_performance.py

# Тестирование производительности задания 3
python test_fibonacci_last_digit_performance.py

# Проверка корректности алгоритмов
python test_correctness.py
```

### Примеры результатов тестирования

#### Тестирование задания 2:

```
ТЕСТИРОВАНИЕ ПРОИЗВОДИТЕЛЬНОСТИ: Задание 2 (Число Фибоначчи)
======================================================================
n     Категория           Результат               Время (сек)
----------------------------------------------------------------------
0     малое               0                        0.000000123
1     малое               1                        0.000000145
5     малое               5                        0.000000234
10    малое               55                       0.000000456
20    среднее             6765                     0.000001234
30    среднее             832040                   0.000002345
40    большое             102334155                0.000003456
45    большое (макс.)     1134903170               0.000004567
----------------------------------------------------------------------

АНАЛИЗ РЕЗУЛЬТАТОВ:
Всего протестировано значений: 8
Минимальное время выполнения: 0.000000123 сек
Максимальное время выполнения: 0.000004567 сек
Среднее время выполнения: 0.000001690 сек

ПРОВЕРКА НА ПРОБЛЕМЫ:
Соотношение времени (большие/малые): 37.13x
✓ Время увеличивается ожидаемо (линейно с n)
```

#### Тестирование задания 3:

```
ТЕСТИРОВАНИЕ ПРОИЗВОДИТЕЛЬНОСТИ: Задание 3 (Последняя цифра Фибоначчи)
================================================================================
n            Категория           Результат   Время (сек)   n mod 60
--------------------------------------------------------------------------------
0            малое               0            0.000000123   0
1            малое               1            0.000000145   1
10           малое               5            0.000000234   10
45           малое               0            0.000000345   45
100          среднее             5            0.000000234   40
1000         среднее             5            0.000000345   40
10000        большое             5            0.000000234   40
100000       большое             5            0.000000345   40
1000000      очень большое       5            0.000000234   40
5000000      очень большое       5            0.000000345   20
10000000     очень большое       5            0.000000234   40
--------------------------------------------------------------------------------

АНАЛИЗ РЕЗУЛЬТАТОВ:
Всего протестировано значений: 12
Минимальное время выполнения: 0.000000123 сек
Максимальное время выполнения: 0.000000456 сек
Среднее время выполнения: 0.000000287 сек

ПРОВЕРКА НА ПРОБЛЕМЫ:
Соотношение времени (очень большие/малые): 1.90x
✓ Отлично! Время выполнения примерно константное (O(1))
  Период Пизано работает эффективно!
```

### Диагностика проблем

**Если алгоритм не работает, возможные причины:**

1. **Неправильный ответ:**
   - Проверить граничные случаи (n = 0, n = 1, максимальные значения)
   - Выполнить несколько тестов с известными ответами
   - Использовать альтернативное решение для проверки

2. **Превышен предел времени:**
   - Измерить время выполнения для малых, средних и больших значений
   - Если время растёт экспоненциально — проблема со сложностью алгоритма
   - Проверить наличие бесконечных циклов

3. **Ошибка времени выполнения:**
   - Проверить доступ к массивам (выход за границы)
   - Проверить деление на ноль
   - Проверить переполнение чисел

### Выводы по заданию 4

При выполнении задания 4 были созданы комплексные тесты для проверки производительности и корректности реализованных алгоритмов:

**Достигнутые результаты:**
- Разработаны автоматизированные скрипты для измерения производительности
- Проведено тестирование для различных размеров входных данных
- Подтверждена корректность работы алгоритмов
- Проверена оптимальность временной сложности

**Результаты тестирования:**
- **Задание 2:** Алгоритм демонстрирует линейную временную сложность O(n), что соответствует ожидаемому поведению
- **Задание 3:** Алгоритм показывает константную временную сложность O(1) благодаря использованию периода Пизано, что подтверждает эффективность оптимизации

**Методология тестирования:**
- Использование `time.perf_counter()` для точного измерения времени
- Сравнение с альтернативными (наивными) реализациями для проверки корректности
- Тестирование граничных случаев и максимальных значений
- Анализ зависимости времени выполнения от размера входных данных



## Структура проекта

```
lab0/
├── sum_ab.py                              # Задание 1, задача 1: a + b (stdin/stdout)
├── sum_ab_squared.py                      # Задание 1, задача 2: a + b² (stdin/stdout)
├── sum_ab_file.py                         # Задание 1, задача 3: a + b (файлы)
├── sum_ab_squared_file.py                 # Задание 1, задача 4: a + b² (файлы)
├── fibonacci.py                           # Задание 2: Число Фибоначчи
├── fibonacci_last_digit.py                # Задание 3: Последняя цифра числа Фибоначчи
├── test_fibonacci_performance.py          # Задание 4: Тест производительности задания 2
├── test_fibonacci_last_digit_performance.py  # Задание 4: Тест производительности задания 3
├── test_correctness.py                    # Задание 4: Проверка корректности алгоритмов
└── README.md                              # Отчёт о лабораторной работе
```


## Выводы

В ходе выполнения лабораторной работы были реализованы программы для работы с базовыми арифметическими операциями и вычисления чисел Фибоначчи:

### Задание 1. Ввод-вывод

1. **Программа `a + b`** со стандартным вводом-выводом — демонстрирует работу с потоком stdin/stdout.
2. **Программа `a + b²`** со стандартным вводом-выводом — показывает использование арифметических операций с возведением в степень.
3. **Программа `a + b`** с файлами — демонстрирует работу с файлами для чтения и записи данных.
4. **Программа `a + b²`** с файлами — комбинирует работу с файлами и вычисления.

### Задание 2. Число Фибоначчи

Реализован эффективный алгоритм вычисления чисел Фибоначчи с использованием динамического программирования. Оптимизация позволила улучшить временную сложность с O(2ⁿ) до O(n) и пространственную сложность до O(1) по сравнению с наивной рекурсивной реализацией.

### Задание 3. Ещё про числа Фибоначчи

Реализован алгоритм для вычисления последней цифры n-го числа Фибоначчи для очень больших значений `n` (до 10⁷). Использованы модульная арифметика и период Пизано, что позволило достичь константной временной сложности O(1) и избежать переполнения при работе с экспоненциально растущими числами.

**Общие особенности реализации:**
- Корректная обработка входных данных
- Проверка граничных значений
- Информативные сообщения об ошибках
- Чистый и читаемый код
- Использование контекстных менеджеров (`with`) для работы с файлами
- Правильная обработка кодировки UTF-8 при работе с файлами
- Оптимизация алгоритмов для эффективного использования вычислительных ресурсов



