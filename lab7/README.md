# Лабораторная работа №7: Динамическое программирование

**Студент:** Джафари Хоссаин

**Выполненные задачи:** 1, 3, 5, 6

## Задача 1: Рогалик (Roguelike)

### Описание
Путешественник должен пройти из левого верхнего угла в правый нижний угол прямоугольной пустыни, собирая максимальное количество монет. Может двигаться только вправо (R) или вниз (D). В каждой клетке может быть сундук с монетами (положительное число) или разбойники (отрицательное число).

### Код

```python
"""
Задача 1: Рогалик (Roguelike)
Путешественник должен пройти из левого верхнего угла в правый нижний угол,
собирая максимальное количество монет. Может двигаться только вправо (R) или вниз (D).
"""

def solve_roguelike(input_file, output_file):
    # Читаем входной файл
    with open(input_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # Парсим CSV файл
    grid = []
    for line in lines:
        line = line.strip()
        if line:
            row = [int(x.strip()) for x in line.split(';')]
            grid.append(row)
    
    n = len(grid)
    m = len(grid[0]) if n > 0 else 0
    
    # Динамическое программирование: dp[i][j] = максимальное количество монет до клетки (i, j)
    dp = [[0] * m for _ in range(n)]
    path = [[''] * m for _ in range(n)]
    
    # Инициализация начальной клетки
    dp[0][0] = grid[0][0]
    
    # Заполняем первую строку (можно двигаться только вправо)
    for j in range(1, m):
        dp[0][j] = dp[0][j-1] + grid[0][j]
        path[0][j] = path[0][j-1] + 'R'
    
    # Заполняем первый столбец (можно двигаться только вниз)
    for i in range(1, n):
        dp[i][0] = dp[i-1][0] + grid[i][0]
        path[i][0] = path[i-1][0] + 'D'
    
    # Заполняем остальные клетки
    for i in range(1, n):
        for j in range(1, m):
            if dp[i-1][j] > dp[i][j-1]:
                dp[i][j] = dp[i-1][j] + grid[i][j]
                path[i][j] = path[i-1][j] + 'D'
            else:
                dp[i][j] = dp[i][j-1] + grid[i][j]
                path[i][j] = path[i][j-1] + 'R'
    
    # Записываем результат
    max_coins = dp[n-1][m-1]
    best_path = path[n-1][m-1]
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(f"{max_coins}\n")
        f.write(best_path)
    
    return max_coins, best_path


if __name__ == "__main__":
    import sys
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    max_coins, path = solve_roguelike('roguelike-input.csv', 'roguelike-output.txt')
    print(f"Максимальное количество монет: {max_coins}")
    print(f"Путь: {path}")
```

### Входные данные (roguelike-input.csv)
```
1;2;3
4;5;6
7;8;9
```

### Вывод после выполнения
```
Максимальное количество монет: 29
Путь: DDRR
```

**Объяснение:** 
- Начальная клетка: 1
- Путь DDRR означает: вниз (1→4), вниз (4→7), вправо (7→8), вправо (8→9)
- Итого: 1 + 4 + 7 + 8 + 9 = 29 монет


## Задача 3: Наибольшая общая подпоследовательность (НОП / LCS)

### Описание
Найти наибольшую общую подпоследовательность двух последовательностей. Подпоследовательность - это последовательность, которая может быть получена из исходной путем удаления некоторых элементов без изменения порядка оставшихся элементов.

### Код

```python
"""
Задача 3: Наибольшая общая подпоследовательность (НОП / LCS)
Найти наибольшую общую подпоследовательность двух последовательностей.
"""

def lcs(seq1, seq2):
    """
    Находит наибольшую общую подпоследовательность двух последовательностей.
    Возвращает длину и саму подпоследовательность.
    """
    n = len(seq1)
    m = len(seq2)
    
    # dp[i][j] = длина НОП для seq1[0:i] и seq2[0:j]
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    
    # Заполняем таблицу динамического программирования
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if seq1[i-1] == seq2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Восстанавливаем подпоследовательность
    lcs_sequence = []
    i, j = n, m
    while i > 0 and j > 0:
        if seq1[i-1] == seq2[j-1]:
            lcs_sequence.append(seq1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    lcs_sequence.reverse()
    return dp[n][m], lcs_sequence


def solve_lcs(input_file):
    """
    Читает входной файл и находит НОП.
    Формат входного файла:
    Первая строка: n (длина первой последовательности)
    Вторая строка: n чисел первой последовательности
    Третья строка: m (длина второй последовательности)
    Четвертая строка: m чисел второй последовательности
    """
    with open(input_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    n = int(lines[0].strip())
    seq1 = list(map(int, lines[1].strip().split()))
    m = int(lines[2].strip())
    seq2 = list(map(int, lines[3].strip().split()))
    
    length, sequence = lcs(seq1, seq2)
    
    print(f"Длина НОП: {length}")
    print(f"НОП: {' '.join(map(str, sequence))}")
    
    return length, sequence


if __name__ == "__main__":
    solve_lcs('lcs-input.txt')
```

### Входные данные (lcs-input.txt)
```
5
1 2 3 4 5
5
2 4 1 3 5
```

### Вывод после выполнения
```
Длина НОП: 3
НОП: 2 4 5
```

**Объяснение:**
- Первая последовательность: [1, 2, 3, 4, 5]
- Вторая последовательность: [2, 4, 1, 3, 5]
- Общие элементы в правильном порядке: 2, 4, 5
- Длина НОП: 3

## Задача 5: Размен монет

### Описание
Найти минимальное количество монет для размена заданной суммы. Даны номиналы монет и сумма, которую нужно разменять. Нужно найти способ размена, используя минимальное количество монет.

### Код

```python
"""
Задача 5: Размен монет
Найти минимальное количество монет для размена заданной суммы.
"""

def coin_change(coins, amount):
    """
    Находит минимальное количество монет для размена суммы amount.
    coins - список номиналов монет
    amount - сумма для размена
    Возвращает минимальное количество монет или -1, если размен невозможен.
    """
    # dp[i] = минимальное количество монет для размена суммы i
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Для суммы 0 нужно 0 монет
    
    # Заполняем таблицу динамического программирования
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1


def coin_change_with_way(coins, amount):
    """
    Находит минимальное количество монет и сам способ размена.
    """
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    parent = [-1] * (amount + 1)  # Для восстановления пути
    
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] + 1 < dp[i]:
                dp[i] = dp[i - coin] + 1
                parent[i] = coin
    
    if dp[amount] == float('inf'):
        return -1, []
    
    # Восстанавливаем способ размена
    way = []
    current = amount
    while current > 0:
        coin = parent[current]
        way.append(coin)
        current -= coin
    
    return dp[amount], way


def solve_coin_change(input_file):
    """
    Читает входной файл и решает задачу размена монет.
    Формат входного файла:
    Первая строка: n (количество номиналов монет)
    Вторая строка: n номиналов монет
    Третья строка: amount (сумма для размена)
    """
    with open(input_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    n = int(lines[0].strip())
    coins = list(map(int, lines[1].strip().split()))
    amount = int(lines[2].strip())
    
    min_coins, way = coin_change_with_way(coins, amount)
    
    if min_coins == -1:
        print(f"Невозможно разменять сумму {amount} данными монетами")
    else:
        print(f"Минимальное количество монет: {min_coins}")
        print(f"Способ размена: {way}")
        print(f"Использованные монеты: {sorted(way, reverse=True)}")
    
    return min_coins, way


if __name__ == "__main__":
    solve_coin_change('coin-change-input.txt')
```

### Входные данные (coin-change-input.txt)
```
3
1 3 4
6
```

### Вывод после выполнения
```
Минимальное количество монет: 2
Способ размена: [3, 3]
Использованные монеты: [3, 3]
```

**Объяснение:**
- Номиналы монет: [1, 3, 4]
- Сумма для размена: 6
- Оптимальный способ: 3 + 3 = 6 (2 монеты)
- Альтернативные способы: 4 + 1 + 1 = 6 (3 монеты) или 1 + 1 + 1 + 1 + 1 + 1 = 6 (6 монет)
- Минимум: 2 монеты

## Задача 6: Редакционное расстояние (расстояние Левенштейна)

### Описание
Найти минимальное количество операций (вставка, удаление, замена символа) для преобразования одной строки в другую. Это классическая задача динамического программирования, используемая в обработке текста, сравнении строк и исправлении ошибок.

### Код

```python
"""
Задача 6: Редакционное расстояние (расстояние Левенштейна)
Найти минимальное количество операций (вставка, удаление, замена) для преобразования
одной строки в другую.
"""

def edit_distance(s1, s2):
    """
    Вычисляет редакционное расстояние между двумя строками.
    Возвращает минимальное количество операций и последовательность операций.
    """
    n = len(s1)
    m = len(s2)
    
    # dp[i][j] = минимальное расстояние между s1[0:i] и s2[0:j]
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    
    # Инициализация: расстояние от пустой строки
    for i in range(n + 1):
        dp[i][0] = i  # Удалить i символов
    for j in range(m + 1):
        dp[0][j] = j  # Вставить j символов
    
    # Заполняем таблицу
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[i-1] == s2[j-1]:
                # Символы совпадают, операция не нужна
                dp[i][j] = dp[i-1][j-1]
            else:
                # Выбираем минимальную из трех операций:
                # 1. Замена: dp[i-1][j-1] + 1
                # 2. Удаление: dp[i-1][j] + 1
                # 3. Вставка: dp[i][j-1] + 1
                dp[i][j] = min(
                    dp[i-1][j-1] + 1,  # Замена
                    dp[i-1][j] + 1,     # Удаление
                    dp[i][j-1] + 1      # Вставка
                )
    
    # Восстанавливаем последовательность операций
    operations = []
    i, j = n, m
    while i > 0 or j > 0:
        if i > 0 and j > 0 and s1[i-1] == s2[j-1]:
            # Символы совпадают, переходим дальше
            i -= 1
            j -= 1
        elif i > 0 and j > 0 and dp[i][j] == dp[i-1][j-1] + 1:
            # Замена
            operations.append(f"Заменить '{s1[i-1]}' на '{s2[j-1]}' в позиции {i-1}")
            i -= 1
            j -= 1
        elif i > 0 and dp[i][j] == dp[i-1][j] + 1:
            # Удаление
            operations.append(f"Удалить '{s1[i-1]}' в позиции {i-1}")
            i -= 1
        else:
            # Вставка
            operations.append(f"Вставить '{s2[j-1]}' в позицию {i}")
            j -= 1
    
    operations.reverse()
    return dp[n][m], operations


def solve_edit_distance(input_file):
    """
    Читает входной файл и вычисляет редакционное расстояние.
    Формат входного файла:
    Первая строка: первая строка
    Вторая строка: вторая строка
    """
    with open(input_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    s1 = lines[0].strip()
    s2 = lines[1].strip()
    
    distance, operations = edit_distance(s1, s2)
    
    print(f"Редакционное расстояние: {distance}")
    print(f"Количество операций: {distance}")
    print("\nПоследовательность операций:")
    for i, op in enumerate(operations, 1):
        print(f"{i}. {op}")
    
    return distance, operations


if __name__ == "__main__":
    solve_edit_distance('edit-distance-input.txt')
```

### Входные данные (edit-distance-input.txt)
```
kitten
sitting
```

### Вывод после выполнения
```
Редакционное расстояние: 3
Количество операций: 3

Последовательность операций:
1. Заменить 'k' на 's' в позиции 0
2. Заменить 'e' на 'i' в позиции 4
3. Вставить 'g' в позицию 6
```

**Объяснение:**
- Исходная строка: "kitten"
- Целевая строка: "sitting"
- Операции:
  1. k → s (замена)
  2. e → i (замена)
  3. Добавить g в конец (вставка)
- Минимальное количество операций: 3


## Общий вывод

В ходе выполнения лабораторной работы я изучил и реализовал четыре классические задачи динамического программирования.

**Задача 1 (Рогалик)** показала, как с помощью динамического программирования можно найти оптимальный путь в двумерной сетке, максимизируя сумму значений. Алгоритм работает за O(n*m) времени и пространства, что эффективно для данной задачи.

**Задача 3 (НОП)** продемонстрировала применение динамического программирования для поиска общей подпоследовательности. Это важная задача в биоинформатике, сравнении текстов и других областях. Алгоритм имеет сложность O(n*m).

**Задача 5 (Размен монет)** научила меня решать задачи оптимизации с помощью динамического программирования. Алгоритм находит не только минимальное количество монет, но и сам способ размена, что очень полезно на практике.

**Задача 6 (Редакционное расстояние)** показала применение динамического программирования в обработке текста. Этот алгоритм используется в системах проверки орфографии, сравнении ДНК-последовательностей и других приложениях.

Все задачи объединяет общий подход: разбиение проблемы на подзадачи, сохранение результатов подзадач в таблице и использование этих результатов для решения более крупных подзадач. Это позволяет избежать повторных вычислений и значительно ускорить решение по сравнению с наивным перебором.

Динамическое программирование - это мощный инструмент для решения оптимизационных задач, который позволяет находить оптимальные решения за полиномиальное время там, где полный перебор был бы недопустимо медленным.
