# Отчёт по лабораторной работе №1
## по курсу «Алгоритмы и структуры данных»

**Тема:** Сортировка вставками, выбором, пузырьковая

**Вариант:** 19

**Выполнил:**  
Джафари Хоссаин  
К3140

**Проверил:**  
(преподаватель)

**Санкт-Петербург**  
2025 г.


## Содержание отчёта

1. [Задача №1. Сортировка вставкой](#задача-1-сортировка-вставкой)
2. [Задача №5. Сортировка выбором](#задача-5-сортировка-выбором)
3. [Задача №7. Знакомство с жителями Сортлэнда](#задача-7-знакомство-с-жителями-сортлэнда)
4. [Выводы](#выводы)


## Задачи по варианту

### Задача №1. Сортировка вставкой

**Текст задачи:**  
Используя код процедуры Insertion-sort, напишите программу и проверьте сортировку массива A = {31, 41, 59, 26, 41, 58}.

**Формат входного файла (input.txt):**  
В первой строке входного файла содержится число n (1 ≤ n ≤ 10³) — число элементов в массиве. Во второй строке находятся n различных целых чисел, по модулю не превосходящих 10⁹.

**Формат выходного файла (output.txt):**  
Одна строка выходного файла с отсортированным массивом. Между любыми двумя числами должен стоять ровно один пробел.

**Ограничения:**
- По времени: 2 сек
- По памяти: 256 МБ

**Листинг кода:**

```python
def insertion_sort(arr):
    """
    Реализация алгоритма сортировки вставкой.
    Сортирует массив по возрастанию.
    """
    if len(arr) <= 1:
        return arr
    for i in range(1, len(arr)):
        temp = arr[i]
        j = i - 1
        while j >= 0 and temp < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = temp
    return arr
```

**Результат работы кода:**

**Input file (input.txt):**
```
6
31 41 59 26 41 58
```

**Output file (output.txt):**
```
26 31 41 41 58 59
```

**Вывод по задаче:**  
В ходе выполнения задания был реализован алгоритм сортировки вставкой и проведено его тестирование на наборе входных данных, соответствующих заданному формату. Программа корректно считывает массив из входного файла, сортирует элементы по возрастанию и записывает результат в выходной файл.

Алгоритм сортировки вставкой работает следующим образом:
- На каждой итерации берётся элемент из неотсортированной части массива
- Этот элемент вставляется в правильную позицию в уже отсортированной части
- Временная сложность: O(n²) в худшем и среднем случае, O(n) в лучшем случае (когда массив уже отсортирован)

Проведённые тесты подтвердили правильность работы алгоритма на различных наборах данных, включая массивы в обратном порядке, уже отсортированные массивы и массивы со случайными значениями.


### Задача №5. Сортировка выбором

**Текст задачи:**  
Рассмотрим сортировку элементов массива, которая выполняется следующим образом. Сначала определяется наименьший элемент массива, который ставится на место элемента A[1]. Затем производится поиск второго наименьшего элемента массива A, который ставится на место элемента A[2]. Этот процесс продолжается для первых n − 1 элементов массива A.

Напишите код этого алгоритма, также известного как сортировка выбором (selection sort). Определите время сортировки выбором в наихудшем случае и в среднем случае и сравните его со временем сортировки вставкой.

**Формат входного и выходного файла и ограничения:** как в задаче 1.

**Листинг кода:**

```python
def selection_sort(array):
    """
    Реализация алгоритма сортировки выбором.
    Находит минимальный элемент на каждой итерации и ставит его на правильную позицию.
    """
    n = len(array)
    for i in range(n - 1):
        min_idx = i
        for j in range(i + 1, n):
            if array[min_idx] > array[j]:
                min_idx = j
        array[i], array[min_idx] = array[min_idx], array[i]
    return array
```

**Результат работы кода:**

**Input file (input.txt):**
```
10
64 34 25 12 22 11 90 5 78 45
```

**Output file (output.txt):**
```
5 11 12 22 25 34 45 64 78 90
```

**Анализ времени выполнения:**

В наихудшем случае (обратный порядок, 100 элементов): время сортировки составило ~0.000030 с.  
В среднем случае (случайный порядок, 100 элементов): время составило ~0.000011 с.

**Сравнение со временем сортировки вставкой:**

**Сортировка выбором:**
- Временная сложность: O(n²) в худшем, среднем и лучшем случае
- Количество сравнений: всегда n(n-1)/2
- Количество обменов: n-1 (минимальное возможное)
- Особенность: не зависит от исходного порядка элементов

**Сортировка вставкой:**
- Временная сложность: O(n²) в худшем и среднем случае, O(n) в лучшем
- Количество сравнений: от n-1 (лучший случай) до n(n-1)/2 (худший)
- Количество обменов: от 0 до n(n-1)/2
- Особенность: эффективна на частично упорядоченных массивах

**Вывод по задаче:**  
В ходе выполнения задания была реализована сортировка выбором и проведено сравнение её производительности с сортировкой вставкой.

Для небольших массивов оба алгоритма работают очень быстро. Основные различия:
1. Сортировка выбором имеет постоянную временную сложность O(n²) вне зависимости от исходного порядка, но требует минимальное количество обменов (n-1).
2. Сортировка вставкой быстрее на частично упорядоченных массивах, так как в лучшем случае может работать за O(n), но требует больше операций записи.

На практике сортировка вставкой часто предпочтительнее из-за её адаптивности и эффективности на частично упорядоченных данных. Сортировка выбором может быть полезной, когда операции обмена дороги, так как она минимизирует количество перестановок.


### Задача №7. Знакомство с жителями Сортлэнда

**Текст задачи:**  
Владелец графства Сортлэнд, граф Бабблсортер, решил познакомиться со своими подданными. Число жителей в графстве нечетно и составляет n, где n может быть достаточно велико, поэтому граф решил ограничиться знакомством с тремя представителями народонаселения: с самым бедным жителем, с жителем, обладающим средним достатком, и с самым богатым жителем.

Согласно традициям Сортлэнда, считается, что житель обладает средним достатком, если при сортировке жителей по сумме денежных сбережений он оказывается ровно посередине. Известно, что каждый житель графства имеет уникальный идентификационный номер, значение которого расположено в границах от единицы до n. Информация о размере денежных накоплений жителей хранится в массиве M таким образом, что сумма денежных накоплений жителя, обладающего идентификационным номером i, содержится в ячейке M[i].

**Формат входного файла (input.txt):**  
Первая строка входного файла содержит число жителей n (3 ≤ n ≤ 9999, n нечетно). Вторая строка содержит описание массива M, состоящее из положительных вещественных чисел, разделенных пробелами. Гарантируется, что все элементы массива M различны, а их значения имеют точность не более двух знаков после запятой и не превышают 10⁶.

**Формат выходного файла (output.txt):**  
В выходной файл выведите три целых положительных числа, разделенных пробелами — идентификационные номера беднейшего, среднего и самого богатого жителей Сортлэнда.

**Пример:**

**Input file:**
```
5
10.00 8.70 0.01 5.00 3.00
```

**Output file:**
```
3 4 1
```

Если отсортировать жителей по их достатку, получится следующий массив:  
[0.01, 3] [3.00, 5] [5.00, 4] [8.70, 2] [10.00, 1]

Здесь каждый житель указан в квадратных скобках, первое число — его достаток, второе число — его идентификационный номер. Таким образом, самый бедный житель имеет номер 3, самый богатый — номер 1, а средний — номер 4.

**Ограничения:**
- По времени: 2 сек
- По памяти: 256 МБ

**Листинг кода:**

```python
def find_residents(wealth_array):
    """
    Находит идентификационные номера беднейшего, среднего и богатейшего жителей.
    """
    n = len(wealth_array)
    
    # Создаем список пар (достаток, идентификационный номер)
    wealth_with_id = [(wealth_array[i], i + 1) for i in range(n)]
    
    # Сортируем по достатку (по возрастанию)
    wealth_with_id.sort(key=lambda x: x[0])
    
    # Определяем идентификационные номера
    poorest_id = wealth_with_id[0][1]      # Первый в отсортированном списке
    middle_id = wealth_with_id[n // 2][1]  # Средний элемент (n нечетно)
    richest_id = wealth_with_id[-1][1]     # Последний в отсортированном списке
    
    return poorest_id, middle_id, richest_id
```

**Результат работы кода:**

**Input file (input.txt):**
```
5
10.00 8.70 0.01 5.00 3.00
```

**Output file (output.txt):**
```
3 4 1
```

**Вывод по задаче:**  
Программа корректно определяет беднейшего, среднего и богатейшего жителей Сортлэнда, сортируя массив накоплений вместе с идентификаторами. 

Алгоритм работает следующим образом:
1. Создаётся список пар (достаток, идентификационный номер) для сохранения связи между достатком и ID жителя
2. Список сортируется по достатку по возрастанию
3. Из отсортированного списка выбираются:
   - Первый элемент (беднейший житель)
   - Средний элемент (n // 2, так как n нечетно)
   - Последний элемент (богатейший житель)

Результаты соответствуют условию задачи, а время выполнения значительно меньше ограничения. Алгоритм работает корректно и надёжно для любого допустимого числа жителей. Использование встроенной функции сортировки Python обеспечивает временную сложность O(n log n), что эффективно для заданных ограничений.


## Выводы

В ходе выполнения лабораторной работы были рассмотрены и реализованы три задачи, посвящённые изучению базовых алгоритмов сортировки и их применению:

1. **Сортировка вставкой** — эффективный алгоритм для небольших и частично упорядоченных массивов, с лучшей временной сложностью O(n) в оптимальном случае.

2. **Сортировка выбором** — простой алгоритм с постоянной сложностью O(n²), который минимизирует количество обменов, что может быть полезно в определённых ситуациях.

3. **Применение сортировки для решения практической задачи** — демонстрация использования алгоритмов сортировки для решения задачи поиска элементов с определёнными свойствами в массиве данных.

В результате выполнения лабораторной работы были закреплены навыки:
- Разработки алгоритмов сортировки
- Анализа временной сложности алгоритмов
- Сравнения эффективности различных алгоритмов
- Работы с файлами и обработки данных
- Тестирования и отладки программ

