## Лабораторная работа 2–4. Подстроки  

Автор отчёта: **Джафари Хоссаин**  

В этой работе я решал три задачи по строковым алгоритмам: наивный поиск подстроки, вычисление Z‑функции и декомпозиция строки в сжатом виде. Для каждой задачи я написал отдельную программу на **Python**, которая читает данные из файла `input.txt` и записывает ответ в `output.txt` в соответствующей папке.


### Задача 1. Наивный поиск подстроки в строке

**Условие (кратко)**  
Даны строки `p` (образец) и `t` (текст). Нужно найти **все** вхождения `p` в `t` как подстроки.  
Во входном файле `input.txt` в первой строке записано `p`, во второй — `t`.  
В `output.txt` в первой строке нужно вывести количество вхождений, во второй — номера позиций (нумерация с 1) начала каждого вхождения в возрастающем порядке.

**Алгоритм**  
Я использую простой наивный алгоритм: для каждой возможной позиции `i` в строке `t` проверяю посимвольно, совпадает ли подстрока `t[i..i+|p|-1]` со строкой `p`. Если совпадает — добавляю позицию `i + 1` в ответ. Сложность алгоритма в худшем случае \(O(|p|\cdot|t|)\), что укладывается в заданные ограничения (до \(10^4\) символов).

**Код программы (`task1/main.py`)**

```python
def main() -> None:
    try:
        with open("input.txt", "r", encoding="utf-8") as fin:
            data = fin.read().strip().splitlines()
    except OSError:
        return

    if len(data) < 2:
        return

    p = data[0].strip()
    t = data[1].strip()

    positions = []
    n, m = len(t), len(p)

    for i in range(0, n - m + 1):
        ok = True
        for j in range(m):
            if t[i + j] != p[j]:
                ok = False
                break
        if ok:
            positions.append(i + 1)  # 1-based

    try:
        with open("output.txt", "w", encoding="utf-8") as fout:
            fout.write(str(len(positions)) + "\n")
            if positions:
                fout.write(" ".join(map(str, positions)))
            fout.write("\n")
    except OSError:
        return


if __name__ == "__main__":
    main()
```

**Пример работы программы**  
Пусть в файле `task1/input.txt` записано:

```text
aba
abaCaba
```

Тогда в файле `task1/output.txt` программа выдаст:

```text
2
1 5
```

**Вывод по задаче 1**  
Наивный перебор всех позиций позволяет легко найти все вхождения подстроки. Алгоритм простой в реализации и при длинах до \(10^4\) работает достаточно быстро.


### Задача 6. Z‑функция

**Условие (кратко)**  
Дана строка `s`. Требуется построить Z‑функцию строки.  
Во входном файле `input.txt` содержится одна строка `s`.  
В выходной файл `output.txt` нужно вывести значения Z‑функции для всех индексов от 2 до \(|s|\) (то есть `Z[1], Z[2], ..., Z[n-1]`, если нумерация с нуля), разделённые пробелами.

**Алгоритм**  
Z‑функция `z[i]` — это длина наибольшего общего префикса строки `s` и её суффикса, начинающегося в позиции `i`. Я реализовал стандартный алгоритм за \(O(n)\) с поддержкой текущего Z‑отрезка `[l, r]`.  
Если `i` попадает внутрь `[l, r]`, то можно взять уже посчитанное значение из `z[i - l]` и дорасширить его сравнением символов.

**Код программы (`task6/main.py`)**

```python
def main() -> None:
    try:
        with open("input.txt", "r", encoding="utf-8") as fin:
            s = fin.read().strip()
    except OSError:
        return

    if not s:
        return

    n = len(s)
    z = [0] * n
    l = r = 0

    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1

    try:
        with open("output.txt", "w", encoding="utf-8") as fout:
            if n > 1:
                fout.write(" ".join(str(z[i]) for i in range(1, n)))
            fout.write("\n")
    except OSError:
        return


if __name__ == "__main__":
    main()
```

**Примеры работы программы**

- Вход `task6/input.txt`:

  ```text
  aaaAAA
  ```

  Выход `task6/output.txt`:

  ```text
  2 1 0 0 0
  ```

- Вход `task6/input.txt`:

  ```text
  abacaba
  ```

  Выход `task6/output.txt`:

  ```text
  0 1 0 3 0 1
  ```

**Вывод по задаче 6**  
Алгоритм Z‑функции за \(O(n)\) позволяет эффективно анализировать структуру строки и пригодится в более сложных задачах на поиск подстроки и периодичность.


### Задача 9. Декомпозиция строки

**Условие (кратко)**  
Дана строка `s`. Нужно представить её в виде выражения минимальной длины, состоящего из фрагментов двух типов:

- просто подстрока `si`,  
- подстрока, умноженная на число: `si*k`, где `k` — целое число \(> 1\).

Фрагменты соединяются знаком `+`. Строка `si*k` обозначает конкатенацию `k` копий подстроки `si`. Знак `*1` писать нельзя — в этом случае нужно использовать просто подстроку. Требуется минимизировать суммарную длину записи (количество символов в итоговой строке).

**Идея решения**  
Я использую динамическое программирование по префиксу строки `s`:

- `dp[i]` — минимальная длина описания префикса `s[0..i)`.  
- Для каждого начала фрагмента `j` и длины фрагмента `L` я рассматриваю подстроку `s[j..j+L)` и проверяю, можно ли её представить как повторение более короткого блока.

Чтобы быстро находить период, для каждого фиксированного `j` я строю префикс‑функцию для суффикса `s[j..]`. Для подстроки длины `L` минимальный период вычисляется как `p = L - pi[L-1]`. Если `L % p == 0`, то `s[j..j+L)` — это `k = L / p` повторов блока длины `p`.  
Стоимость одного фрагмента:

- если `k = 1`, то просто `L` (длина самой подстроки),  
- если `k > 1`, то `p + 1 + digits(k)` (подстрока, звёздочка и число).  

Плюс ко всем фрагментам, кроме первого, добавляется 1 символ за знак `'+'`. В конце я восстанавливаю само описание, идя по массиву предков.

**Код программы (`task9/main.py`)**

```python
from math import inf


def digits_count(x: int) -> int:
    cnt = 0
    while x > 0:
        cnt += 1
        x //= 10
    return max(cnt, 1)


def main() -> None:
    try:
        with open("input.txt", "r", encoding="utf-8") as fin:
            s = fin.read().strip()
    except OSError:
        return

    if not s:
        return

    n = len(s)
    dp = [inf] * (n + 1)
    prev_pos = [-1] * (n + 1)
    seg_start = [-1] * (n + 1)
    seg_len = [0] * (n + 1)
    seg_rep = [1] * (n + 1)

    dp[0] = 0

    # Для каждого старта j считаем префикс-функцию на суффиксе s[j:]
    for j in range(n):
        m = n - j
        pi = [0] * m
        for i in range(1, m):
            k = pi[i - 1]
            while k > 0 and s[j + i] != s[j + k]:
                k = pi[k - 1]
            if s[j + i] == s[j + k]:
                k += 1
            pi[i] = k

        for L in range(1, m + 1):
            total_len = L
            p = total_len - pi[total_len - 1]
            reps = 1
            if total_len % p == 0:
                reps = total_len // p
            else:
                p = total_len
                reps = 1

            if reps == 1:
                cost_segment = total_len
            else:
                cost_segment = p + 1 + digits_count(reps)  # pattern*reps

            i = j + L
            add_plus = 1 if j > 0 else 0
            cand = dp[j] + cost_segment + add_plus
            if cand < dp[i]:
                dp[i] = cand
                prev_pos[i] = j
                seg_start[i] = j
                seg_len[i] = p
                seg_rep[i] = reps

    # Восстановление ответа
    parts = []
    cur = n
    while cur > 0:
        j = prev_pos[cur]
        st = seg_start[cur]
        base_len = seg_len[cur]
        reps = seg_rep[cur]
        base = s[st : st + base_len]
        if reps == 1:
            piece = base
        else:
            piece = f"{base}*{reps}"
        parts.append(piece)
        cur = j

    parts.reverse()

    try:
        with open("output.txt", "w", encoding="utf-8") as fout:
            fout.write("+".join(parts) + "\n")
    except OSError:
        return


if __name__ == "__main__":
    main()
```

**Примеры работы программы**

- Вход `task9/input.txt`:

  ```text
  ABCABCDEDEDEF
  ```

  Возможный выход `task9/output.txt`:

  ```text
  ABC*2+DE*3+F
  ```

- Вход `task9/input.txt`:

  ```text
  Hello
  ```

  Возможный выход `task9/output.txt`:

  ```text
  Hello
  ```

**Вывод по задаче 9**  
Комбинация динамического программирования и префикс‑функции позволяет находить оптимальное разбиение строки и выгодные повторяющиеся блоки. При ограничении длины строки до \(5 \cdot 10^3\) выбранный алгоритм по времени и памяти подходит.


## Общий вывод по лабораторной работе

В этой лабораторной работе я познакомился с разными строковыми алгоритмами: от простого наивного поиска до более продвинутых структур, таких как Z‑функция и префикс‑функция. Я увидел, как наивные решения легко реализуются, но более эффективные алгоритмы позволяют работать с большими строками и решать сложные задачи, например оптимальное сжатие представления строки. В результате выполнения заданий я лучше понял, как устроены периодичность строк и поиск подстрок, и как можно использовать динамическое программирование вместе со строковыми функциями.

