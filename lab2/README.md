# Отчёт по лабораторной работе №2
## по курсу «Алгоритмы и структуры данных»

**Тема:** Сортировка слиянием (Merge Sort)

**Вариант:** 19

**Выполнил:**  
Джафари Хоссаин  
К3140



**Санкт-Петербург**  
2025 г.


## Содержание отчёта

1. [Задача №1. Реализация сортировки слиянием](#задача-1-реализация-сортировки-слиянием)
2. [Задача №5. Подсчёт инверсий с помощью Merge Sort](#задача-5-подсчёт-инверсий-с-помощью-merge-sort)
3. [Задача №7. Итеративная версия Merge Sort](#задача-7-итеративная-версия-merge-sort)
4. [Выводы](#выводы)


## Задачи по варианту

### Задача №1. Реализация сортировки слиянием

**Текст задачи:**  
Используя код процедуры Merge-Sort, напишите программу и проверьте сортировку массива A = {38, 27, 43, 3, 9, 82, 10, 16}.

**Формат входного файла (input.txt):**  
В первой строке входного файла содержится число n (1 ≤ n ≤ 10⁵) — число элементов в массиве. Во второй строке находятся n целых чисел, по модулю не превосходящих 10⁹.

**Формат выходного файла (output.txt):**  
Одна строка выходного файла с отсортированным массивом. Между любыми двумя числами должен стоять ровно один пробел.

**Ограничения:**
- По времени: 2 сек
- По памяти: 256 МБ

**Листинг кода:**

```python
def merge_sort(arr):
    """
    Реализация алгоритма сортировки слиянием (Merge Sort).
    Сортирует массив по возрастанию, используя принцип "разделяй и властвуй".
    """
    if len(arr) <= 1:
        return arr
    
    # Делим массив пополам
    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])
    
    # Сливаем отсортированные половины
    return merge(left_half, right_half)


def merge(left, right):
    """
    Функция слияния двух отсортированных массивов в один отсортированный.
    """
    merged = []
    left_index = 0
    right_index = 0
    
    # Сравниваем элементы из обоих массивов и добавляем меньший
    while left_index < len(left) and right_index < len(right):
        if left[left_index] <= right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    
    # Добавляем оставшиеся элементы
    merged.extend(left[left_index:])
    merged.extend(right[right_index:])
    
    return merged
```

**Результат работы кода:**

**Input file (input.txt):**
```
8
38 27 43 3 9 82 10 16
```

**Output file (output.txt):**
```
3 9 10 16 27 38 43 82
```

**Вывод программы:**
```
Исходный массив: [38, 27, 43, 3, 9, 82, 10, 16]
Отсортированный массив: [3, 9, 10, 16, 27, 38, 43, 82]
```

**Вывод по задаче:**  
В ходе выполнения задания была реализована сортировка слиянием и проведено её тестирование на наборе входных данных, соответствующих заданному формату. Программа корректно считывает массив из входного файла, сортирует элементы по возрастанию и записывает результат в выходной файл.

Алгоритм сортировки слиянием работает следующим образом:
- Массив рекурсивно делится пополам до тех пор, пока не останутся массивы из одного элемента
- Затем отсортированные подмассивы объединяются (сливаются) в один отсортированный массив
- Функция merge сравнивает элементы из двух отсортированных массивов и формирует общий отсортированный массив
- Временная сложность: O(n log n) во всех случаях (худший, средний, лучший)
- Пространственная сложность: O(n) из-за необходимости дополнительной памяти для хранения подмассивов

Проведённые тесты подтвердили правильность работы алгоритма. Массив [38, 27, 43, 3, 9, 82, 10, 16] был успешно отсортирован в [3, 9, 10, 16, 27, 38, 43, 82].


### Задача №5. Подсчёт инверсий с помощью Merge Sort

**Текст задачи:**  
Реализуйте алгоритм подсчёта количества инверсий в массиве с помощью сортировки слиянием. Инверсия — это пара индексов (i, j), где i < j и arr[i] > arr[j].

**Листинг кода:**

```python
def merge_and_count(left, right):
    """
    Функция слияния двух отсортированных массивов с подсчётом инверсий.
    Инверсия возникает, когда элемент из правого массива меньше элемента из левого.
    """
    merged = []
    inversions = 0
    left_index = 0
    right_index = 0
    
    while left_index < len(left) and right_index < len(right):
        if left[left_index] <= right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            # Все оставшиеся элементы в left больше текущего элемента right
            inversions += len(left) - left_index
            right_index += 1
    
    merged.extend(left[left_index:])
    merged.extend(right[right_index:])
    
    return merged, inversions


def count_inversions_merge_sort(arr):
    """
    Подсчёт количества инверсий в массиве с помощью сортировки слиянием.
    Инверсия - это пара индексов (i, j), где i < j и arr[i] > arr[j].
    """
    if len(arr) <= 1:
        return arr, 0
    
    mid = len(arr) // 2
    left_arr, left_inversions = count_inversions_merge_sort(arr[:mid])
    right_arr, right_inversions = count_inversions_merge_sort(arr[mid:])
    
    merged, merge_inversions = merge_and_count(left_arr, right_arr)
    total_inversions = left_inversions + right_inversions + merge_inversions
    
    return merged, total_inversions
```

**Результат работы кода:**

```
============================================================
Задача 5: Подсчёт инверсий с помощью Merge Sort
============================================================
Исходный массив: [38, 27, 43, 3, 9, 82, 10, 16]
Отсортированный массив: [3, 9, 10, 16, 27, 38, 43, 82]
Количество инверсий: 15
============================================================

Дополнительные примеры:
------------------------------------------------------------
Массив [2, 4, 1, 3, 5]: 3 инверсий
Массив [5, 4, 3, 2, 1]: 10 инверсий
Массив [1, 2, 3, 4, 5]: 0 инверсий
Массив [1, 3, 2]: 1 инверсий
```

**Вывод по задаче:**  
В ходе выполнения задания была реализована модифицированная версия сортировки слиянием, которая подсчитывает количество инверсий в массиве. Алгоритм использует тот же принцип "разделяй и властвуй", что и обычная сортировка слиянием, но дополнительно считает инверсии во время процесса слияния.

Основные принципы работы:
- При слиянии двух отсортированных массивов, когда элемент из правого массива меньше элемента из левого, это означает, что данный элемент правого массива образует инверсии со всеми оставшимися элементами левого массива
- Общее количество инверсий равно сумме инверсий в левой части, правой части и инверсий, найденных при слиянии
- Временная сложность: O(n log n), что совпадает со сложностью обычной сортировки слиянием
- Пространственная сложность: O(n) для хранения подмассивов

Тестирование показало, что алгоритм корректно подсчитывает инверсии. Для массива [38, 27, 43, 3, 9, 82, 10, 16] было найдено 15 инверсий. Для полностью обращённого массива [5, 4, 3, 2, 1] количество инверсий равно 10 (максимальное для массива из 5 элементов), а для уже отсортированного массива инверсий нет (0).


### Задача №7. Итеративная версия Merge Sort

**Текст задачи:**  
Реализуйте итеративную версию сортировки слиянием, которая не использует рекурсию, а работает с помощью циклов.

**Листинг кода:**

```python
def merge(arr, left, mid, right):
    """
    Функция слияния двух отсортированных подмассивов arr[left..mid] и arr[mid+1..right].
    Работает in-place, используя вспомогательный массив.
    """
    # Создаём временные массивы для левой и правой частей
    left_arr = arr[left:mid + 1]
    right_arr = arr[mid + 1:right + 1]
    
    i = j = 0
    k = left
    
    # Сливаем временные массивы обратно в arr[left..right]
    while i < len(left_arr) and j < len(right_arr):
        if left_arr[i] <= right_arr[j]:
            arr[k] = left_arr[i]
            i += 1
        else:
            arr[k] = right_arr[j]
            j += 1
        k += 1
    
    # Копируем оставшиеся элементы
    while i < len(left_arr):
        arr[k] = left_arr[i]
        i += 1
        k += 1
    
    while j < len(right_arr):
        arr[k] = right_arr[j]
        j += 1
        k += 1


def iterative_merge_sort(arr):
    """
    Итеративная версия сортировки слиянием.
    Вместо рекурсии использует циклы для объединения подмассивов.
    """
    n = len(arr)
    # Начинаем с подмассивов размером 1, затем увеличиваем размер
    current_size = 1
    
    while current_size < n:
        left = 0
        while left < n - 1:
            # Находим конец первого подмассива
            mid = min(left + current_size - 1, n - 1)
            
            # Находим конец второго подмассива
            right = min(left + 2 * current_size - 1, n - 1)
            
            # Сливаем подмассивы arr[left..mid] и arr[mid+1..right]
            if mid < right:
                merge(arr, left, mid, right)
            
            left += 2 * current_size
        
        # Увеличиваем размер подмассивов в два раза
        current_size *= 2
    
    return arr
```

**Результат работы кода:**

```
============================================================
Задача 7: Итеративная версия Merge Sort
============================================================
Исходный массив: [38, 27, 43, 3, 9, 82, 10, 16]
Отсортированный массив: [3, 9, 10, 16, 27, 38, 43, 82]
============================================================

Дополнительные примеры:
------------------------------------------------------------
Исходный: [64, 34, 25, 12, 22, 11, 90] -> Отсортированный: [11, 12, 22, 25, 34, 64, 90]
Исходный: [5, 2, 8, 1, 9] -> Отсортированный: [1, 2, 5, 8, 9]
Исходный: [1] -> Отсортированный: [1]
Пустой массив -> Отсортированный: []
```

**Вывод по задаче:**  
В ходе выполнения задания была реализована итеративная версия сортировки слиянием, которая работает без использования рекурсии. Вместо рекурсивных вызовов алгоритм использует вложенные циклы для объединения подмассивов различного размера.

Основные особенности итеративной версии:
- Алгоритм начинается с подмассивов размером 1 (каждый элемент уже отсортирован)
- На каждой итерации размер подмассивов удваивается
- Подмассивы объединяются попарно до тех пор, пока весь массив не будет отсортирован
- Временная сложность: O(n log n), такая же, как у рекурсивной версии
- Пространственная сложность: O(n) для вспомогательных массивов при слиянии
- Преимущество: отсутствие рекурсии означает, что нет риска переполнения стека вызовов

Итеративная версия может быть предпочтительнее рекурсивной в некоторых случаях, особенно при работе с очень большими массивами или в системах с ограниченным размером стека. Однако она немного сложнее для понимания из-за необходимости управления индексами вручную.

Тестирование подтвердило, что итеративная версия корректно сортирует массивы любого размера, включая крайние случаи (пустой массив, массив из одного элемента). Результаты совпадают с рекурсивной версией алгоритма.


## Выводы

В ходе выполнения лабораторной работы №2 были изучены и реализованы различные версии алгоритма сортировки слиянием (Merge Sort). Выполнены три задачи: базовая реализация сортировки слиянием, подсчёт инверсий с помощью модифицированной версии алгоритма, и итеративная версия без использования рекурсии.

**Основные результаты:**

1. **Базовая реализация Merge Sort** — успешно реализован классический рекурсивный алгоритм сортировки слиянием. Алгоритм корректно работает на различных входных данных, обеспечивая стабильную сортировку с временной сложностью O(n log n). Протестирован на массиве [38, 27, 43, 3, 9, 82, 10, 16], который был успешно отсортирован.

2. **Подсчёт инверсий** — реализована модифицированная версия алгоритма, которая не только сортирует массив, но и подсчитывает количество инверсий. Это демонстрирует гибкость подхода "разделяй и властвуй" и возможность решения дополнительных задач без существенного увеличения сложности алгоритма.

3. **Итеративная версия** — создана версия алгоритма без использования рекурсии, которая работает с помощью циклов. Это показывает альтернативный способ реализации того же алгоритма, имеющий свои преимущества в определённых ситуациях.

**Общие выводы:**

Сортировка слиянием является мощным и универсальным алгоритмом сортировки. Она имеет гарантированную временную сложность O(n log n) во всех случаях, что делает её предсказуемой и надёжной. Алгоритм стабилен (сохраняет порядок равных элементов) и может быть адаптирован для решения различных задач, таких как подсчёт инверсий.

Основным недостатком алгоритма является необходимость дополнительной памяти O(n), но это часто является приемлемой платой за стабильность и предсказуемость производительности. Итеративная версия показывает, что тот же алгоритм может быть реализован по-разному, что расширяет область его применения.

