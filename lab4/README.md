# Лабораторная работа №4: Стек, очередь, связный список

**Вариант:** 19  
**Студент:** Джафари Хоссаин

## Содержание
1. [Введение](#введение)
2. [Задание 1: Стек](#задание-1-стек)
3. [Задание 4: Расширенная проверка скобок](#задание-4-расширенная-проверка-скобок)
4. [Задание 6: Очередь с минимумом](#задание-6-очередь-с-минимумом)
5. [Задание 7: Максимум в скользящем окне](#задание-7-максимум-в-скользящем-окне)
6. [Запуск](#запуск)
7. [Общий вывод](#общий-вывод)

---

## Введение

Лабораторная работа посвящена базовым структурам данных: стек, очередь, двусторонняя очередь/дек. По варианту 19 требуются задачи **1, 4, 6, 7** из файла «Задание к Лаб 4 Stack Queue Linked List.pdf». Для каждой задачи подготовлены решения на Python, тестовые входные данные и пример вывода.


## Задание 1: Стек
**Формулировка:** поддержать операции «+ N» (push) и «-» (pop), выводить все извлечённые элементы. Гарантируется, что извлечения из пустого стека нет, размер стека ≤ 10⁶.

**Реализация:** список Python как стек, построчная обработка команд. Все операции O(1), итог O(M).

**Файлы:** `task1/stack_basic.py`, вход `task1/input.txt`, вывод `task1/output.txt`.

**Полученный вывод на примере:**  
`task1/output.txt` → `10`, `1234` (каждое в новой строке).

## Задание 4: Расширенная проверка скобок
**Формулировка:** проверить корректность скобок из набора `()[]{}` в строке. Если ошибка, выдать индекс первой проблемной скобки; если всё верно — `Success`.

**Реализация:** стек пар (символ, позиция). При встрече закрывающей скобки проверяется соответствие вершине стека. В конце, если остались открывающие, возвращается индекс первой из них. Время O(|S|), память O(|S|).

**Файлы:** `task4/bracket_checker.py`, вход `task4/input.txt`, вывод `task4/output.txt`.

**Полученный вывод на примере:**  
`task4/output.txt` → `10` (первый неверный символ в строке `foo(bar[i);`).

## Задание 6: Очередь с минимумом
**Формулировка:** реализовать очередь с командами «+ N», «-», «?» (минимум). Все операции должны быть амортизированно O(1); извлечения/запросы из пустой очереди не происходят.

**Реализация:** очередь на двух стэках, каждый хранит значение и текущий минимум. При необходимости элементы перекладываются из входного стека в выходной с пересчётом минимумов. Минимум очереди — минимум из верхушек обоих стеков.

**Файлы:** `task6/queue_with_min.py`, вход `task6/input.txt`, вывод `task6/output.txt`.

**Полученный вывод на примере:**  
`task6/output.txt` → `1`, `1`, `10`.

## Задание 7: Максимум в скользящем окне
**Формулировка:** для массива `a1..an` и ширины окна `m` вывести максимум для каждого окна `{a_i..a_{i+m-1}}`. Требуемая сложность — O(n).

**Реализация:** дек индексов в порядке убывания значений. Перед добавлением нового элемента из правого края удаляются все меньшие/равные, из левого края — индексы, вышедшие за окно. Максимум окна всегда в начале дека. Время O(n), память O(m).

**Файлы:** `task7/sliding_window_max.py`, вход `task7/input.txt`, вывод `task7/output.txt`.

**Полученный вывод на примере:**  
`task7/output.txt` → `7 7 5 6 6`.

## Запуск
Для каждой задачи вход — `input.txt` в её каталоге, выход — `output.txt` рядом. Пример для задачи 1 (аналогично для остальных):
```bash
python task1/stack_basic.py
python task4/bracket_checker.py
python task6/queue_with_min.py
python task7/sliding_window_max.py
```

## Общий вывод
- Стек/очередь реализуются за O(1) на базовых списках, но задачи 6 и 7 требуют дополнительных структур (двойной стек, дек), чтобы сохранять нужные свойства (минимум/максимум) без потери эффективности.  
- Правильная работа со скобками — классический пример применения стека; важно учитывать индексирование для дружелюбной диагностики.  
- Поддержка минимумов и максимумов «на лету» показывает, как перераспределение данных (двойной стек, упорядоченный дек) позволяет держать асимптотику O(1)/O(n).  
- Простыми словами: я научился использовать стек и очередь не только для базовых push/pop, но и для быстрых подсказок вроде «какой сейчас минимум/максимум» и для аккуратной проверки кода на скобочные ошибки.
